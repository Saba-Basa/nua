SOFTWARE REASONING TEMPLATE
===========================

ANCHOR
------
What software unit is this?
(function / class / module / pipeline step)


STEP 0 — CLASSIFY
-----------------
What is being implemented?

Definition:
What is this unit?

Responsibility:
What SINGLE job does it perform?

Trigger:
When is this executed?

Design Reason:
Why must this exist as its own unit?

Boundary:
What must it NOT handle?


STEP 1 — ISOLATE UNIT
=====================
WHAT operation is it?
Isolates Operation identity

INPUT:
<raw description or code purpose>

--------------------------------

A) DELETE NON-COMPUTATION WORDS

Cross out anything that answers:
- Who uses this?
- Where does it appear?
- Why does it exist?
- What product/domain is it for?
- UI / API / business context
- Examples

Keep ONLY what changes data or state.

Result:
<short sentence>


--------------------------------

B) EXTRACT CORE ACTION

Rewrite as:

VERB + SINGLE COMPOSITE OBJECT

Rules:
- One verb only
- One object only
- No adjectives

Result:
<verb phrase>


--------------------------------

C) STRUCTURAL NORMALIZATION

Replace semantic nouns with data structures:

Apply:
- dataset → table
- file → stream/buffer
- user → record
- form → input fields
- response → output payload
- object → struct
- list of items → collection
- json → document
- model input → feature matrix
- target → vector
- config → parameter set

Result:
<structure-based phrase>


--------------------------------

D) COMPRESS OPERATION LABEL

Rules:
- 2–4 words
- Remove articles (a, the)
- Prefer noun+noun or verb+noun

Output:

OPERATION NAME:
<final label>


STEP 2 — INPUT / OUTPUT
-----------------------

INPUT
-----

What is the input name?
<name>

What role does it play?
[ ] Primary data      — main data being transformed
[ ] Configuration     — parameters controlling behavior
[ ] Control signal    — flags, modes, commands
[ ] Context state     — shared/session state

What structure is it?
[ ] Primitive     — int, float, bool, string
[ ] Collection    — list, array, set
[ ] Table         — DataFrame, 2D array
[ ] Object        — class instance / struct
[ ] Stream        — iterator, file handle
[ ] State         — mutable shared data
[ ] Signal        — event / message

What is its concrete type?
(select closest match or write custom)

[ ] Built-in primitive
    Examples:
    - int / float / bool / str (Python)
    - int / double / boolean / String (Java)
    - number / boolean / string (JS)

[ ] Collection type
    Examples:
    - list / tuple / set / dict (Python)
    - ArrayList / HashMap (Java)
    - Array / Map / Set (JS)

[ ] Table / Matrix type
    Examples:
    - pandas.DataFrame
    - numpy.ndarray
    - torch.Tensor
    - 2D array

[ ] Object / Struct type
    Examples:
    - CustomClass
    - dataclass
    - DTO / POJO
    - Record / Struct

[ ] Stream / IO type
    Examples:
    - file handle
    - BufferedReader
    - InputStream
    - Iterator / Generator

[ ] State / Context type
    Examples:
    - Session object
    - Cache entry
    - Redux store
    - Global state object

[ ] Signal / Message type
    Examples:
    - Event object
    - Message queue payload
    - HTTP Request / Response
    - WebSocket message

[ ] Custom / Domain type
    Specify:
    <type name>

Who owns this data?
[ ] Caller-owned       — input not modified
[ ] New instance       — created internally
[ ] In-place mutation  — modified directly


OUTPUT
------

What is the output name?
(Variable / return identifier)
<name>

What role does it play?
[ ] Primary result     — main computation outcome
[ ] Derived data       — helper/secondary result
[ ] Control signal     — status/flag for flow control

What structure is it?
(Choose by DATA SHAPE and BEHAVIOR — not by library)


[ ] Primitive    
WHY:
- Single atomic value
- No internal structure
- Represents one fact

Examples:
int, float, bool, string

DO NOT choose if:
- More than one value exists
- Data is iterable or indexed


------------------------------------------------


[ ] Collection   
WHY:
- 1D sequence of multiple values
- Indexable or iterable
- Vector-like structure

SUBTYPE (select one):

[ ] Dense numeric vector
    WHY:
    - Continuous numeric values
    - Fixed length
    Examples:
    numpy.ndarray (1D), torch.Tensor (1D)

[ ] Labeled vector
    WHY:
    - Values associated with index/labels
    Examples:
    pandas.Series

[ ] Generic list
    WHY:
    - Possibly heterogeneous values
    - Order matters
    Examples:
    Python list, JS Array, Java List

[ ] Sparse vector
    WHY:
    - Mostly zero values
    - Memory optimized
    Examples:
    scipy.sparse vector

DO NOT choose Collection if:
- Data has rows AND columns → use Table
- Represents a single structured entity → use Object


------------------------------------------------


[ ] Table        
WHY:
- 2D structured data (rows × columns)
- Column schema exists
- Dataset or matrix representation

SUBTYPE (select one):

[ ] Dense table
    WHY:
    - Fully materialized numeric/categorical data
    Examples:
    pandas.DataFrame, numpy 2D array

[ ] Sparse table
    WHY:
    - Many missing/zero values
    Examples:
    scipy sparse matrix

[ ] Indexed table
    WHY:
    - Requires row identifiers
    Examples:
    DataFrame with index/key column

DO NOT choose Table if:
- Only one column / 1D → use Collection
- Represents one entity → use Object


------------------------------------------------


[ ] Object       
WHY:
- Represents ONE entity
- Named attributes/fields
- Semantic grouping

SUBTYPE (select one):

[ ] Plain data object
    WHY:
    - Data container only
    Examples:
    dataclass, DTO, struct

[ ] Domain object
    WHY:
    - Contains behavior + data
    Examples:
    business entity class

DO NOT choose Object if:
- Homogeneous list of values → use Collection
- Dataset-like structure → use Table


------------------------------------------------


[ ] Stream       
WHY:
- Data arrives sequentially over time
- Not fully loaded in memory
- Consumed progressively

SUBTYPE (select one):

[ ] File/IO stream
    Examples:
    file handle, InputStream

[ ] Iterator/Generator
    Examples:
    Python generator, Java iterator

[ ] Async stream
    Examples:
    async iterator, reactive stream

DO NOT choose Stream if:
- Entire dataset is already in memory → use Collection/Table


------------------------------------------------


[ ] State        
WHY:
- Mutable shared data
- Persists across operations
- Represents system memory

SUBTYPE (select one):

[ ] Session state
    Examples:
    user session object

[ ] Cache state
    Examples:
    Redis entry, in-memory cache

[ ] Global/shared state
    Examples:
    Redux store, singleton state

DO NOT choose State if:
- Temporary function input/output → use Collection/Object/Table


------------------------------------------------


[ ] Signal       
WHY:
- Represents event or message
- Triggers behavior
- Carries notification intent

SUBTYPE (select one):

[ ] Event object
    Examples:
    UI event, system event

[ ] Message payload
    Examples:
    queue message, WebSocket message

[ ] Request/Response
    Examples:
    HTTP request object

DO NOT choose Signal if:
- Data is stored or transformed → use Collection/Object/Table



What is its concrete type?
(Language / library specific)
Examples:
- pandas.DataFrame
- pandas.Series
- list[int]
- torch.Tensor
- CustomClass

OUTPUT COUNT
------------

How many independent output artifacts leave this unit boundary?


[ ] Single  

WHY:
- Exactly ONE artifact is produced
- Output is consumed as ONE unit
- No independent secondary artifact exists

Choose this if:
- There is one return object OR
- There is one persistent effect OR
- There is one emitted signal

SUBTYPE (select one):


[ ] Single value result

WHY:
- Output is ONE atomic value
- No internal structure
- Represents scalar information

Examples:
Numeric:
- count, score, threshold

Boolean:
- success flag, validation result

Text:
- status message, label

Identifier:
- id, reference key


--------------------------------


[ ] Single data artifact

WHY:
- Output is ONE structured data container
- Contains multiple values internally
- Treated as ONE transferable unit

Choose this if:
- Output is a table, collection, object, or stream
- Downstream consumes it as one entity

Examples:
- dataset table
- object instance
- vector/collection
- stream handle

DO NOT choose if:
- Outputs are separated into independent artifacts


--------------------------------


[ ] Single state mutation

WHY:
- Unit modifies exactly ONE persistent state target
- Effect is observable outside unit boundary

Examples:
- write one file
- update one database record
- modify one cache entry


--------------------------------


[ ] Single signal emission

WHY:
- Unit produces exactly ONE event/message
- Used to trigger downstream behavior

Examples:
- emit one event
- send one command
- publish one message


================================================


[ ] Multiple  

WHY:
- More than ONE independent artifact is produced
- Outputs are logically separable
- Can be consumed independently

Choose this if:
- Two or more artifacts cross the boundary


SUBTYPE (select one):


[ ] Data + Data

WHY:
- Two or more independent data artifacts

Examples:
- two collections
- table + vector
- object + metadata object


--------------------------------


[ ] Data + State

WHY:
- Data is produced AND persistent state is modified

Examples:
- return object + save record
- response payload + cache update


--------------------------------


[ ] Data + Signal

WHY:
- Data output AND event/message emission

Examples:
- return result + notify system


--------------------------------


[ ] State + State

WHY:
- Multiple persistent updates

Examples:
- update two database records
- modify multiple caches


--------------------------------


[ ] Signal + Signal

WHY:
- Multiple events/messages emitted

Examples:
- broadcast notifications
- multi-channel messaging


================================================


SIDE OUTPUTS
------------

Does this unit change anything OUTSIDE its main output artifacts?


[ ] None

WHY:
- No external system affected
- No global/shared state modified
- Only return values are produced


[ ] Logs

WHY:
- Writes human-readable diagnostics
- Does not affect logic flow


[ ] Metrics

WHY:
- Emits performance/monitoring signals
- Used for observation, not logic


[ ] Events

WHY:
- Triggers reactions in other systems
- Causes behavior elsewhere


--------------------------------


DECISION PROCEDURE:

Ask:

"Does something change that is NOT part of the main output?"

If YES → side output exists  
If NO → None


STEP 3 — SYSTEM POSITION
------------------------
Where does this live?

BEFORE:
What runs before it?

AFTER:
What consumes its output?

Dependency Role
---------------

Select ONE:

[ ] PRODUCER
Creates data or state.
No required upstream computation input.

[ ] TRANSFORMER
Takes input and outputs transformed data.
Passes result forward in pipeline.

[ ] CONSUMER
Uses input to produce final result or side effect.
Terminates data flow.

Decision Rule:
If output feeds another computation → TRANSFORMER  
If output is final artifact/side effect → CONSUMER  
If input originates externally → PRODUCER

STEP 4 — SCOPE CONTROL
---------------------

INCLUDED LOGIC
--------------
What responsibilities are ALLOWED inside this unit?
(select all that apply)


[ ] Structural transformation
WHY:
- Changes data shape without changing meaning

Includes:
- splitting, merging
- reshaping (wide ↔ long)
- column/field reordering
- schema mapping
- renaming fields

DO NOT include:
- value normalization
- statistical processing
- domain interpretation


--------------------------------


[ ] Data selection / filtering
WHY:
- Chooses subset of existing data

Includes:
- column selection
- row filtering by condition
- field extraction
- subset slicing

DO NOT include:
- feature engineering
- derived calculations
- business rule filtering


--------------------------------


[ ] Parameter interpretation
WHY:
- Uses function inputs to control behavior

Includes:
- interpreting flags
- applying thresholds
- selecting modes
- routing logic based on parameters

DO NOT include:
- configuration loading
- environment variable reading
- dynamic runtime setup


--------------------------------


[ ] Validation (local)
WHY:
- Ensures inputs satisfy THIS unit’s contract

Includes:
- type checking
- null/empty checks
- field existence checks
- shape validation

DO NOT include:
- cross-system validation
- database consistency checks
- business validation rules


--------------------------------


[ ] Pure computation
WHY:
- Deterministic transformation of input to output

Includes:
- arithmetic
- aggregation
- mapping functions
- mathematical transforms

DO NOT include:
- IO
- randomness without control
- time-based logic


--------------------------------


[ ] Format / representation conversion
WHY:
- Changes representation without semantic change

Includes:
- object → table
- table → array
- encoding format conversion
- serialization/deserialization (local only)

DO NOT include:
- storage writing
- network transmission
- compression pipelines


--------------------------------


[ ] Local error signaling
WHY:
- Reports violations of this unit’s responsibility

Includes:
- raising exceptions
- returning error codes
- validation errors

DO NOT include:
- retry logic
- fallback logic
- error recovery strategies


================================================


EXCLUDED LOGIC
--------------
What responsibilities are FORBIDDEN inside this unit?
(select all that apply)


[ ] External IO
WHY:
- Interacts with outside world

Includes:
- file reads/writes
- database queries
- API calls
- hardware access

FORBIDDEN because:
- Breaks testability
- Introduces side effects


--------------------------------


[ ] Persistence / storage management
WHY:
- Manages long-term data lifecycle

Includes:
- saving objects
- loading state
- caching layers
- checkpoints

FORBIDDEN because:
- Belongs to infrastructure layer


--------------------------------


[ ] Domain / business rules
WHY:
- Application-specific decision logic

Includes:
- pricing rules
- validation policies
- workflow conditions
- product logic

FORBIDDEN because:
- Makes unit non-reusable


--------------------------------


[ ] Workflow orchestration
WHY:
- Coordinates multiple units

Includes:
- pipeline control
- task scheduling
- branching logic
- job coordination

FORBIDDEN because:
- Violates single responsibility


--------------------------------


[ ] Global/shared state management
WHY:
- Modifies system-wide memory

Includes:
- session updates
- cache mutation
- global variable access

FORBIDDEN because:
- Introduces hidden coupling


--------------------------------


[ ] User interface / presentation
WHY:
- Controls how results are shown

Includes:
- rendering
- formatting for display
- UI interaction

FORBIDDEN because:
- Mixing logic and presentation


--------------------------------


[ ] Monitoring / observability
WHY:
- Operational instrumentation

Includes:
- logging
- metrics emission
- tracing

FORBIDDEN because:
- Side-effect responsibility


--------------------------------


[ ] Error recovery strategies
WHY:
- Alters failure behavior

Includes:
- retries
- fallback logic
- circuit breakers

FORBIDDEN because:
- Belongs to control layer


--------------------------------


[ ] Security concerns
WHY:
- Access control and protection logic

Includes:
- authentication
- authorization
- encryption

FORBIDDEN because:
- Cross-cutting concern


--------------------------------


[ ] Performance optimization
WHY:
- Alters execution characteristics

Includes:
- caching
- batching
- parallelization

FORBIDDEN because:
- Architecture-level responsibility


--------------------------------


[ ] Resource management
WHY:
- Controls system resources

Includes:
- memory handling
- thread pools
- connection pools

FORBIDDEN because:
- Infrastructure concern


--------------------------------


[ ] Configuration loading
WHY:
- Reads environment/runtime settings

Includes:
- env variables
- config files
- runtime flags

FORBIDDEN because:
- Initialization responsibility


================================================


BOUNDARY VALIDATION
-------------------

Check all:

[ ] Only transforms provided inputs
[ ] No external system touched
[ ] No hidden state modified
[ ] One responsibility only

If any unchecked → scope violation


STEP 5 — IMPLEMENTATION DECISION
--------------------------------

REUSE STRATEGY
--------------
Should existing tools/libraries be used?

[ ] Built-in language features
WHY:
- Prefer standard library for reliability and maintainability
Examples:
list operations, dict access, file utilities

[ ] Third-party library
WHY:
- Specialized, optimized implementation exists
Examples:
pandas operations, numpy math, framework utilities

[ ] Custom implementation
WHY:
- No suitable library exists
- Special logic required
- Performance or control constraints

DECISION CHECK:
Is this logic already implemented reliably elsewhere?
[ ] Yes → Reuse
[ ] No → Implement manually

--------------------------------


IMPLEMENTATION MAPPING
----------------------
IF REUSE

For EACH core operation in this unit:

Operation:
<from STEP 1 / STEP 4>

Target Structure:
<from STEP 2>

Library / Tool:
<selected reuse tool>

Capability Category:
[ ] Selection
[ ] Transformation
[ ] Aggregation
[ ] Conversion
[ ] Validation
[ ] IO

API Primitive:
<method / operator / function>

Minimal Expression:
<code snippet>


STATE MODEL
-----------
Does this unit maintain internal state?

[ ] Stateless
WHY:
- Output depends only on input parameters
- No memory between calls
- Easier to test and parallelize

Choose if:
- Pure function behavior
- No cached values
- No internal counters


[ ] Stateful
WHY:
- Unit keeps memory across executions

Choose if:
- Caches results
- Maintains counters
- Stores session/context data

STATE TYPE (if stateful):
[ ] Local instance state
[ ] Shared/global state
[ ] Persistent state


--------------------------------


SIDE EFFECT POLICY
------------------
Are side effects allowed inside this unit?

[ ] Forbidden (pure unit)
WHY:
- Predictable behavior
- Easier testing
- No hidden system impact

Means:
- No IO
- No global state mutation
- No external calls


[ ] Restricted
WHY:
- Only specific controlled effects allowed

Allowed effects:
[ ] Logging
[ ] Metrics
[ ] Local caching
[ ] Temporary file creation


[ ] Allowed
WHY:
- Unit is designed to interact with system

Allowed effects:
[ ] File IO
[ ] Database access
[ ] Network communication
[ ] Hardware interaction


--------------------------------


ERROR HANDLING POLICY
---------------------
How should this unit react to invalid input or failure?

[ ] Fail-fast
WHY:
- Stop immediately on invalid input
- Surface error to caller

Examples:
raise exception, return error code


[ ] Graceful fallback
WHY:
- Continue execution with default behavior

Examples:
return default value, skip item


[ ] Retry logic
WHY:
- Recover from transient failure

Examples:
retry on network error


--------------------------------


PERFORMANCE CONSTRAINTS
-----------------------
Are there performance requirements?

[ ] None
[ ] Low latency required
[ ] High throughput required
[ ] Memory constrained
[ ] Real-time constraint


--------------------------------


THREADING / CONCURRENCY MODEL
-----------------------------
Is this unit concurrency-aware?

[ ] Single-threaded
[ ] Thread-safe
[ ] Async-compatible
[ ] Parallel execution safe



STEP 5.5 — CODE BINDING
-----------------------
Unit Type:
(function / class / module)

Identifier Name:
What will this unit be called in code?

Input Signature:
Parameter names and types?

Output Signature:
Return type and structure?

Error Strategy:
Fail-fast / exceptions / fallback?

Side Effects:
None / logging / IO / state?


STEP 6 — RESOLVE
----------------
One-sentence contract:

"Takes ___ and produces ___ for ___."

